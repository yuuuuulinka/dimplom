import { Test } from '../types/practice';

export const getTests = (): Test[] => {
  return [
    {
      id: 'test-intro-graph-theory',
      title: 'Вступ до теорії графів',
      description: 'Перевірте своє розуміння основних понять теорії графів, включаючи вершини, ребра та основні властивості.',
      materialId: 'intro-graph-theory',
      category: 'basics',
      difficulty: 'easy',
      estimatedTime: 10,
      passingScore: 70,
      questions: [
        {
          id: 'q1-intro',
          question: 'Що таке граф в теорії графів?',
          options: [
            'Математична структура, що складається з вершин та ребер',
            'Візуальна діаграма, що показує тенденції даних',
            'Тип комп\'ютерного алгоритму',
            'Програмні дані тільки'
          ],
          correctAnswer: 0,
          explanation: 'Граф в теорії графів - це математична структура, що складається з множини вершин (вузлів), з\'єднаних ребрами.'
        },
        {
          id: 'q2-intro',
          question: 'Що таке степінь вершини?',
          options: [
            'Вага вершини',
            'Кількість ребер, що інциденті (з\'єднані) вершині',
            'Відстань від корневої вершини',
            'Значення, збережене в вершині'
          ],
          correctAnswer: 1,
          explanation: 'Степінь вершини - це кількість ребер, що інциденті (з\'єднані) вершині.'
        },
        {
          id: 'q3-intro',
          question: 'В неорієнтованому графі, яка мінімальна кількість вершин потрібна для того, щоб утворити цикл?',
          options: ['2', '3', '4', '5'],
          correctAnswer: 1,
          explanation: 'В неорієнтованому графі, потрібно принаймні 3 вершини для того, щоб утворити цикл (трикутник).'
        },
        {
          id: 'q4-intro',
          question: 'Що таке повний граф?',
          options: [
            'Граф без ребер',
            'Граф, де кожна вершина з\'єднана з кожною іншою вершиною',
            'Граф з точно одним циклом',
            'Граф з рівними вхідними та вихідними степенями для всіх вершин'
          ],
          correctAnswer: 1,
          explanation: 'Повний граф - це граф, у якому кожна вершина з\'єднана з кожною іншою вершиною ребром.'
        },
        {
          id: 'q5-intro',
          question: 'Що відрізняє орієнтований граф від неорієнтованого?',
          options: [
            'Орієнтовані графи мають ваги на ребрах',
            'Орієнтовані графи мають менше вершин',
            'Орієнтовані графи мають ребра з напрямком (порядок має значення)',
            'Орієнтовані графи не можуть мати цикли'
          ],
          correctAnswer: 2,
          explanation: 'В орієнтованому графі ребра мають напрямок, тобто зв\'язок від вершини A до B відрізняється від зв\'язку від B до A.'
        }
      ]
    },
    {
      id: 'test-graph-representations',
      title: 'Представлення графів',
      description: 'Перевірте своє розуміння різних методів представлення графів, включаючи матриці суміжності та списки суміжності.',
      materialId: 'graph-representations',
      category: 'basics',
      difficulty: 'easy',
      estimatedTime: 20,
      passingScore: 70,
      questions: [
        {
          id: 'q1-repr',
          question: 'В матриці суміжності, яке значення на позиції (i,j) вказує на наявність ребра від вершини i до вершини j?',
          options: [
            'Вершина i має степінь 1',
            'Існує ребро від вершини i до вершини j',
            'Вершина j є корнем графа',
            'Граф має тільки одну компоненту'
          ],
          correctAnswer: 1,
          explanation: 'В матриці суміжності, значення 1 на позиції (i,j) вказує на наявність ребра від вершини i до вершини j.'
        },
        {
          id: 'q2-repr',
          question: 'Яка складність простору для матриці суміжності графа з V вершинами?',
          options: ['O(V)', 'O(V²)', 'O(V log V)', 'O(E)'],
          correctAnswer: 1,
          explanation: 'Матриця суміжності потребує O(V²) простору, оскільки потрібно зберігати значення для кожної можливої пари вершин.'
        },
        {
          id: 'q3-repr',
          question: 'Який метод представлення є більш раціональним для розріджених графів?',
          options: [
            'Матриця суміжності',
            'Список суміжності',
            'Список ребер',
            'Як матриця суміжності, так і список однаково ефективні'
          ],
          correctAnswer: 1,
          explanation: 'Список суміжності є більш раціональним для розріджених графів, оскільки вони лише зберігають існуючі ребра, використовуючи O(V+E) простору.'
        },
        {
          id: 'q4-repr',
          question: 'У представленні списку ребер, як зазвичай зберігається кожне ребро?',
          options: [
            'Як одне число',
            'Як пара (або трійка з вагою) вершин',
            'Як рядок матриці',
            'Як вузол списку'
          ],
          correctAnswer: 1,
          explanation: 'У списку ребер, кожне ребро зберігається як пара вершин (або трійка, якщо вага), перелічуючи всі ребра в графі.'
        },
        {
          id: 'q5-repr',
          question: 'Яка часова складність перевірки наявності ребра між двома певними вершинами в матриці суміжності?',
          options: ['O(1)', 'O(V)', 'O(E)', 'O(V²)'],
          correctAnswer: 0,
          explanation: 'Перевірка наявності ребра в матриці суміжності є O(1), оскільки вона передбачає прямий доступ до елемента масиву на позиції (i,j).'
        }
      ]
    },
    {
      id: 'test-bfs-algorithm',
      title: 'Пошук у ширину тест',
      description: 'Перевірте своє розуміння алгоритму BFS, його реалізації та застосувань в обході графів.',
      materialId: 'bfs-algorithm',
      category: 'algorithms',
      difficulty: 'medium',
      estimatedTime: 25,
      passingScore: 75,
      questions: [
        {
          id: 'q1-bfs',
          question: 'Яка структура даних зазвичай використовується для реалізації BFS?',
          options: ['Стек', 'Черга', 'Черга пріоритетів', 'Хеш-таблиця'],
          correctAnswer: 1,
          explanation: 'BFS використовує чергу, щоб забезпечити обробку вершин у порядку їх виявлення (FIFO - First In, First Out - перший прийшов, перший вийшов).'
        },
        {
          id: 'q2-bfs',
          question: 'Яка часова складність BFS для графа з V вершинами та E ребрами?',
          options: ['O(V)', 'O(E)', 'O(V + E)', 'O(V²)'],
          correctAnswer: 2,
          explanation: 'BFS відвідує кожну вершину один раз і перевіряє кожне ребро один раз, що дає часову складність O(V + E).'
        },
        {
          id: 'q3-bfs',
          question: 'У якому типі графа BFS можна використовувати для знаходження найкоротшого шляху?',
          options: [
            'Тільки орієнтовані графи',
            'Тільки зважені графи',
            'Незважені графи',
            'Тільки повні граф'
          ],
          correctAnswer: 2,
          explanation: 'BFS знаходить найкоротший шлях в незважених графах, оскільки досліджує вершини рівень за рівнем.'
        },
        {
          id: 'q4-bfs',
          question: 'У BFS вершини на якій відстані обробляються раніше, ніж вершини на відстані d+1?',
          options: [
            'Відстань d-1',
            'Відстань d',
            'Відстань d+2',
            'Будь-яка відстань'
          ],
          correctAnswer: 1,
          explanation: 'BFS обробляє всі вершини на відстані d, перш ніж обробити будь-яку вершину на відстані d+1 від джерела.'
        },
        {
          id: 'q5-bfs',
          question: 'Який з наступних методів НЕ є типовим застосуванням BFS?',
          options: [
            'Знаходження найкоротшого шляху в незважених графах',
            'Обхід рівнем за рівнем',
            'Знаходження сильно зв\'язаних компонентів',
            'Веб-скрапінг'
          ],
          correctAnswer: 2,
          explanation: 'Для пошуку сильно зв\'язних компонентів зазвичай використовуються алгоритми на основі DFS, а не BFS.'
        }
      ]
    },
    {
      id: 'test-dfs-algorithm',
      title: 'Пошук в глибину тест',
      description: 'Перевірте свої знання алгоритму DFS, його застосування у виявленні циклів та топологічному сортуванні.',
      materialId: 'dfs-algorithm',
      category: 'algorithms',
      difficulty: 'medium',
      estimatedTime: 25,
      passingScore: 75,
      questions: [
        {
          id: 'q1-dfs',
          question: 'Яка структура даних зазвичай використовується для реалізації DFS?',
          options: ['Черга', 'Стек', 'Черга пріоритетів', 'Масив'],
          correctAnswer: 1,
          explanation: 'DFS використовує стек (або рекурсію, яка використовує стек викликів) для того, щоб гарантувати, що найпізніше виявлена вершина обробляється першою (LIFO - Last In, First Out).'
        },
        {
          id: 'q2-dfs',
          question: 'Яка часова складність DFS для графа з V вершинами та E ребрами?',
          options: ['O(V)', 'O(E)', 'O(V + E)', 'O(V log E)'],
          correctAnswer: 2,
          explanation: 'DFS відвідує кожну вершину один раз і перевіряє кожне ребро один раз, що дає часову складність O(V + E).'
        },
        {
          id: 'q3-dfs',
          question: 'DFS можна використовувати для виявлення циклів в якому типі графа?',
          options: [
            'Тільки неорієнтовані графи',
            'Тільки орієнтовані графи',
            'Як орієнтовані, так і неорієнтовані графи',
            'Тільки зважені графи'
          ],
          correctAnswer: 2,
          explanation: 'DFS може виявляти цикли в як орієнтованих, так і в неорієнтованих графах, використовуючи різні методи (зворотні ребра).'
        },
        {
          id: 'q4-dfs',
          question: 'Що допомагає визначити DFS у топологічному сортуванні?',
          options: [
            'Найкоротший шлях між вершинами',
            'Порядок завершення вершин',
            'Мінімальне кістякове дерево',
            'Діаметр графа'
          ],
          correctAnswer: 1,
          explanation: 'У топологічному сортуванні, DFS визначає порядок завершення вершин, що дає топологічний порядок у зворотному порядку.'
        },
        {
          id: 'q5-dfs',
          question: 'Що таке задній край у DFS?',
          options: [
            'Ребро до вже відвіданої вершини в поточному шляху',
            'Ребро, що йде назад у списку суміжності',
            'Останнє ребро, оброблене в DFS',
            'Ребро з негативною вагою'
          ],
          correctAnswer: 0,
          explanation: 'Задній край з\'єднує вершину з одним з її предків у дереві DFS, що вказує на цикл в орієнтованих графах.'
        }
      ]
    },
    {
        id: 'test-dijkstra-algorithm',
        title: 'Тест на знання алгоритму Дейкстри',
        description: 'Перевірте свої знання про алгоритм Дейкстри для пошуку найкоротшого шляху та деталі його реалізації.',
        materialId: 'dijkstra-algorithm',
        category: 'algorithms',
        difficulty: 'hard',
        estimatedTime: 30,
        passingScore: 80,
        questions: [
          {
            id: 'q1-dijkstra',
            question: 'Які типи графів може обробляти алгоритм Дейкстри?',
            options: [
              'Тільки графи з від\'ємними вагами',
              'Тільки графи з невід\'ємними вагами',
              'Будь-які вагові графи',
              'Тільки незважені графіки'
            ],
            correctAnswer: 1,
            explanation: 'Алгоритм Дейкстри працює правильно тільки з графіками, що мають невід\'ємні ваги ребер.'
          },
          {
            id: 'q2-dijkstra',
            question: 'Яка структура даних зазвичай використовується для ефективної реалізації алгоритму Дейкстри?',
            options: ['Стек', 'Черга', 'Черга пріоритетів (мінімальний куп)', 'Хеш-таблиця'],
            correctAnswer: 2,
            explanation: 'Черга пріоритетів (мінімальний куп) використовується для ефективного вилучення вершини з мінімальною відстанню на кожному кроці.'
          },
          {
            id: 'q3-dijkstra',
            question: 'Яка часова складність алгоритму Дейкстри при використанні бінарного купа?',
            options: ['O(V²)', 'O((V + E) log V)', 'O(VE)', 'O(E log E)'],
            correctAnswer: 1,
            explanation: 'Використовуючи бінарний куп, алгоритм Дейкстри має часову складність O((V + E) log V) завдяки операціям з купом.'
          },
          {
            id: 'q4-dijkstra',
            question: 'Що робить крок релаксації в алгоритмі Дейкстри?',
            options: [
              'Видаляє вершини з графа',
              'Оновлює відстань, якщо знайдено коротший шлях',
              'Додає нові ребра до графа',
              'Сортує вершини за вагою'
            ],
            correctAnswer: 1,
            explanation: 'Релаксація оновлює відстань до вершини, якщо знайдено коротший шлях через поточну вершину.'
          },
          {
            id: 'q5-dijkstra',
            question: 'Чому алгоритм Дейкстри не працює з від\'ємними вагами ребер?',
            options: [
              'Він стає занадто повільним',
              'Він використовує занадто багато пам\'яті',
              'Жадібний вибір може бути не оптимальним',
              'Він не може представляти від\'ємні числа'
            ],
            correctAnswer: 2,
            explanation: 'З від\'ємними вагами жадібний вибір, який завжди вибирає найближчу вершину, може не привести до оптимального рішення.'
          }
        ]
      },
      {
        id: 'test-minimum-spanning-trees',
        title: 'Тест на мінімальне кістякове дерево',
        description: 'Перевірте свої знання концепцій MST та алгоритмів Прима і Крускала.',
        materialId: 'minimum-spanning-trees',
        category: 'algorithms',
        difficulty: 'hard',
        estimatedTime: 30,
        passingScore: 80,
        questions: [
            {
            id: 'q1-mst',
            question: 'Що таке кістякове дерево?',
            options: [
                'Дерево, яке включає всі вершини графа',
                'Дерево з максимальною кількістю ребер',
                'Дерево з рівно V-1 ребрами, де V - кількість вершин',
                'Обидві відповіді A і C правильні'
            ],
          correctAnswer: 3,
         explanation: 'Кістякове дерево включає всі вершини і має рівно V-1 ребер, що робить його деревом, яке покриває весь граф.'
        },
        {
            id: 'q2-mst',
            question: 'Який алгоритм використовує пріоритетну чергу для вибору ребер?',
            options: [
                'Алгоритм Крускала',
                'Алгоритм Прима',
                'Обидва алгоритми',
                'Жоден алгоритм'
            ],
          correctAnswer: 1,
          explanation: 'Алгоритм Прима використовує чергу з пріоритетом для вибору ребра мінімальної ваги, що з\'єднує MST з вершиною, яка не є MST.'
        },
        {
            id: 'q3-mst',
            question: 'Яку структуру даних використовує алгоритм Крускала для виявлення циклів?',
            options: ['Стек', 'Черга', 'Об\'єднання-Пошук (Непересічна множина)', 'Хеш-таблиця'],
            correctAnswer: 2,
            explanation: 'Алгоритм Крускала використовує структуру даних Об\'єднання-Пошук для ефективного виявлення того, чи додавання ребра створить цикл.'
        },
            {
            id: 'q4-mst',
            question: 'У якому порядку алгоритм Крускала обробляє ребра?',
            options: [
            'Випадковий порядок',
            'Порядок появи у списку суміжності',
            'Відсортовано за вагою (за зростанням)',
            'Відсортовано за вагою (за спаданням)'
            ],
            correctAnswer: 2,
            explanation: 'Алгоритм Крускала сортує всі ребра за вагою і обробляє їх у порядку зростання ваги.'
        },
            {
            id: 'q5-mst',
            question: 'Яка мінімальна кількість ребер у MST зв\'язного графа з V вершинами?',
            options: ['V', 'V-1', 'V+1', '2V'],
            correctAnswer: 1,
            explanation: 'MST зв\'язного графа з V вершинами завжди має рівно V-1 ребер.'
        }
    ]
    },
    {
      id: 'test-social-network-analysis',
      title: 'Тест з аналізу соціальних мереж',
      description: 'Перевірте своє розуміння того, як теорія графів застосовується у соціальних мереж та виявлення спільнот.',
      materialId: 'social-network-analysis',
      category: 'applications',
      difficulty: 'medium',
      estimatedTime: 25,
      passingScore: 75,
      questions: [
        {
          id: 'q1-social',
          question: 'В аналізі соціальних мереж, що зазвичай представляє вершина?',
          options: [
            'Відношення між людьми',
            'Особу або організацію',
            'Відправлене повідомлення',
            'Період часу'
          ],
          correctAnswer: 1,
          explanation: 'У соціальних мережах вершини представляють окремих осіб, організації або інші сутності в мережі.'
        },
        {
          id: 'q2-social',
          question: 'Що вимірює центральність посередництва?',
          options: [
            'Скільки друзів має особа',
            'Як часто особа з\'являється на найкоротших шляхах між іншими',
            'Наскільки популярна особа',
            'Як недавно особа приєдналася до мережі'
          ],
          correctAnswer: 1,
          explanation: 'Центральність посередництва вимірює, як часто вершина лежить на найкоротших шляхах між іншими вершинами, вказуючи на її роль як моста.'
        },
        {
          id: 'q3-social',
          question: 'Що таке спільнота в аналізі соціальних мереж?',
          options: [
            'Група людей, що живуть в одному районі',
            'Щільно з\'єднана підгрупа з рідкісними з\'єднаннями з іншими групами',
            'Люди з однаковою професією',
            'Користувачі, які приєдналися до платформи одночасно'
          ],
          correctAnswer: 1,
          explanation: 'Спільнота - це підгрупа вершин, які більш щільно з\'єднані між собою, ніж з рештою мережі.'
        },
        {
          id: 'q4-social',
          question: 'Яка міра центральності визначає найбільш "популярних" або добре з\'єднаних осіб?',
          options: [
            'Центральність ступеня',
            'Центральність посередництва',
            'Центральність близькості',
            'Центральність власного вектора'
          ],
          correctAnswer: 0,
          explanation: 'Центральність ступеня просто підраховує кількість прямих з\'єднань, визначаючи найбільш з\'єднаних осіб.'
        },
        {
          id: 'q5-social',
          question: 'Яке явище описує властивість "малого світу"?',
          options: [
            'Мережі мають дуже мало вершин',
            'Більшість людей живуть у малих спільнотах',
            'Короткі шляхи існують між більшістю пар вершин незважаючи на низьку зв\'язність',
            'Соціальні мережі завжди дуже щільні'
          ],
          correctAnswer: 2,
          explanation: 'Властивість малого світу означає, що незважаючи на те, що більшість вершин мають мало з\'єднань, короткі шляхи існують між більшістю пар вершин.'
        }
      ]
    },
    {
      id: 'test-graph-coloring',
      title: 'Тест з розфарбування графів',
      description: 'Перевірте свої знання у проблемі розфарбування графів та їх застосування в плануванні та оптимізації.',
      materialId: 'graph-coloring',
      category: 'advanced',
      difficulty: 'hard',
      estimatedTime: 30,
      passingScore: 80,
      questions: [
        {
          id: 'q1-coloring',
          question: 'Яке основне обмеження в розфарбуванні графів?',
          options: [
            'Використовувати мінімальну кількість кольорів',
            'Суміжні вершини повинні мати різні кольори',
            'Всі вершини повинні мати однаковий колір',
            'Кольори повинні призначатися в алфавітному порядку'
          ],
          correctAnswer: 1,
          explanation: 'Основне обмеження в розфарбуванні графів полягає в тому, що жодні дві суміжні вершини не можуть мати однаковий колір.'
        },
        {
          id: 'q2-coloring',
          question: 'Що таке хроматичне число графа?',
          options: [
            'Загальна кількість вершин',
            'Загальна кількість ребер',
            'Мінімальна кількість кольорів, необхідна для правильного розфарбування',
            'Максимальний ступінь будь-якої вершини'
          ],
          correctAnswer: 2,
          explanation: 'Хроматичне число - це мінімальна кількість кольорів, необхідна для розфарбування графа так, щоб жодні суміжні вершини не мали однаковий колір.'
        },
        {
          id: 'q3-coloring',
          question: 'Яке хроматичне число повного графа з n вершинами?',
          options: ['1', '2', 'n-1', 'n'],
          correctAnswer: 3,
          explanation: 'У повному графі кожна вершина суміжна з кожною іншою вершиною, тому кожна вершина потребує унікального кольору, що вимагає n кольорів.'
        },
        {
          id: 'q4-coloring',
          question: 'Яку реальну проблему можна змоделювати як розфарбування графів?',
          options: [
            'Планування іспитів',
            'Розподіл регістрів у компіляторах',
            'Розфарбування карт',
            'Всі вище перелічені'
          ],
          correctAnswer: 3,
          explanation: 'Розфарбування графів має багато застосувань, включаючи планування іспитів, розподіл регістрів, призначення частот та розфарбування карт.'
        },
        {
          id: 'q5-coloring',
          question: 'Яке хроматичне число двочасткового графа?',
          options: ['1', '2', '3', 'Залежить від кількості вершин'],
          correctAnswer: 1,
          explanation: 'Двочастковий граф завжди можна розфарбувати рівно 2 кольорами, оскільки вершини можна розділити на два незалежні множини.'
        }
      ]
    },
    {
      id: 'test-network-flow',
      title: 'Тест з алгоритмів мережевих потоків',
      description: 'Перевірте своє розуміння проблем максимального потоку/мінімального розрізу та алгоритмів як Форд-Фалкерсон.',
      materialId: 'network-flow',
      category: 'advanced',
      difficulty: 'hard',
      estimatedTime: 35,
      passingScore: 80,
      questions: [
        {
          id: 'q1-flow',
          question: 'У мережі потоків, що представляє пропускну здатність ребра?',
          options: [
            'Фактичний потік через ребро',
            'Максимальний потік, який може пройти через ребро',
            'Вартість використання ребра',
            'Довжина ребра'
          ],
          correctAnswer: 1,
          explanation: 'Пропускна здатність ребра - це максимальна кількість потоку, яка може пройти через це ребро.'
        },
        {
          id: 'q2-flow',
          question: 'Що таке теорема про максимальний потік - мінімальний розріз?',
          options: [
            'Максимальний потік дорівнює мінімальній вартості',
            'Максимальний потік дорівнює мінімальній пропускній здатності',
            'Максимальний потік дорівнює пропускній здатності мінімального розрізу',
            'Максимальний потік дорівнює кількості ребер'
          ],
          correctAnswer: 2,
          explanation: 'Теорема про максимальний потік - мінімальний розріз стверджує, що максимальний потік від джерела до стоку дорівнює пропускній здатності мінімального розрізу.'
        },
        {
          id: 'q3-flow',
          question: 'Що таке збільшуючий шлях в алгоритмі Форд-Фалкерсона?',
          options: [
            'Найкоротший шлях від джерела до стоку',
            'Шлях від джерела до стоку з доступною пропускною здатністю',
            'Шлях з максимальною пропускною здатністю',
            'Будь-який шлях у залишковому графі'
          ],
          correctAnswer: 1,
          explanation: 'Збільшуючий шлях - це шлях від джерела до стоку в залишковому графі, де можна протолкнути додатковий потік.'
        },
        {
          id: 'q4-flow',
          question: 'Яка мета залишкового графа?',
          options: [
            'Зберігати оригінальний граф',
            'Відстежувати доступну пропускну здатність для додаткового потоку',
            'Знаходити найкоротші шляхи',
            'Зберігати фінальні значення потоку'
          ],
          correctAnswer: 1,
          explanation: 'Залишковий граф показує залишкову пропускну здатність на кожному ребрі, вказуючи, де можна відправити додатковий потік.'
        },
        {
          id: 'q5-flow',
          question: 'Яке з наступного є практичним застосуванням алгоритмів максимального потоку?',
          options: [
            'Сегментація зображень',
            'Двочасткове паросполучення',
            'Аналіз зв\'язності мережі',
            'Всі вищеперелічені'
          ],
          correctAnswer: 3,
          explanation: 'Алгоритми максимального потоку мають багато застосувань, включаючи сегментацію зображень, двочасткове паросполучення та аналіз надійності мережі.'
        }
      ]
    },
    {
      id: 'test-prim-algorithm',
      title: 'Тест з алгоритму Прима',
      description: 'Перевірте своє розуміння алгоритму Прима для знаходження мінімальних кістякових дерев.',
      materialId: 'prim-algorithm',
      category: 'algorithms',
      difficulty: 'hard',
      estimatedTime: 30,
      passingScore: 80,
      questions: [
        {
          id: 'q1-prim',
          question: 'Яка часова складність алгоритму Прима?',
          options: ['O(V²)', 'O(E log V)', 'O(V log V)', 'O(E²)'],
          correctAnswer: 1,
          explanation: 'Алгоритм Прима має часову складність O(E log V) при реалізації з двійковою купою як черга з пріоритетом.'
        },
        {
          id: 'q2-prim',
          question: 'Що робить крок релаксації в алгоритмі Прима?',
          options: [
            'Видаляє вершини з графа',
            'Оновлює відстань, якщо знайдено коротший шлях',
            'Додає нові ребра до графа',
            'Сортує вершини за вагою'
          ],
          correctAnswer: 1,
          explanation: 'Релаксація оновлює відстань до вершини, якщо знайдено коротший шлях через поточну вершину.'
        },
        {
          id: 'q3-prim',
          question: 'Яка основна перевага алгоритму Прима над алгоритмом Крускала?',
          options: [
            'Він швидший для щільних графів',
            'Він повільніший для щільних графів',
            'Він швидший для розріджених графів',
            'Він повільніший для розріджених графів'
          ],
          correctAnswer: 0,
          explanation: 'Алгоритм Прима швидший для щільних графів, оскільки він будує МКД по одній вершині за раз.'
        },
        {
          id: 'q4-prim',
          question: 'Яка структура даних зазвичай використовується для ефективної реалізації алгоритму Прима?',
          options: ['Стек', 'Черга', 'Черга з пріоритетом (мін-купа)', 'Хеш-таблиця'],
          correctAnswer: 2,
          explanation: 'Черга з пріоритетом (мін-купа) використовується для ефективного витягування вершини з мінімальною відстанню на кожному кроці.'
        },
        {
          id: 'q5-prim',
          question: 'Яка мінімальна кількість ребер у МКД зв\'язного графа з V вершинами?',
          options: ['V', 'V-1', 'V+1', '2V'],
          correctAnswer: 1,
          explanation: 'МКД зв\'язного графа з V вершинами завжди має рівно V-1 ребер.'
        }
      ]
    },
    {
      id: 'test-kruskal-algorithm',
      title: 'Тест з алгоритму Крускала',
      description: 'Перевірте своє розуміння алгоритму Крускала для знаходження мінімальних кістякових дерев.',
      materialId: 'kruskal-algorithm',
      category: 'algorithms',
      difficulty: 'hard',
      estimatedTime: 30,
      passingScore: 80,
      questions: [
        {
          id: 'q1-kruskal',
          question: 'Яка часова складність алгоритму Крускала?',
          options: ['O(V²)', 'O(E log E)', 'O(V log V)', 'O(E²)'],
          correctAnswer: 1,
          explanation: 'Алгоритм Крускала має часову складність O(E log E) через сортування ребер, що домінує над операціями Union-Find.'
        },
        {
          id: 'q2-kruskal',
          question: 'Яка основна перевага алгоритму Крускала над алгоритмом Прима?',
          options: [
            'Він швидший для щільних графів',
            'Він повільніший для щільних графів',
            'Він швидший для розріджених графів',
            'Він повільніший для розріджених графів'
          ],
          correctAnswer: 2,
          explanation: 'Алгоритм Крускала швидший для розріджених графів, оскільки він обробляє ребра одне за одним без побудови MКД.'
        },
        {
          id: 'q3-kruskal',
          question: 'Яку структуру даних використовує алгоритм Крускала для виявлення циклів?',
          options: [
            'Стек',
            'Черга',
            'Union-Find (система неперетинних множин)',
            'Хеш-таблиця'
          ],
          correctAnswer: 2,
          explanation: 'Алгоритм Крускала використовує структуру даних Union-Find для ефективного визначення того, чи не створить додавання ребра цикл.'
        },
        {
          id: 'q4-kruskal',
          question: 'Що робить крок сортування в алгоритмі Крускала?',
          options: [
            'Видаляє вершини з графа',
            'Оновлює відстань, якщо знайдено коротший шлях',
            'Додає нові ребра до графа',
            'Сортує ребра за вагою'
          ],
          correctAnswer: 3,
          explanation: 'Сортування ребер за вагою дозволяє алгоритму Крускала ефективно виявляти цикли та додає ребра до MКД.'
        },
        {
          id: 'q5-kruskal',
          question: 'Яка мінімальна кількість ребер у MКД зв\'язного графа з V вершинами?',
          options: ['V', 'V-1', 'V+1', '2V'],
          correctAnswer: 1,
          explanation: 'Мінімальне кістякове дерево зв\'язного графа з V вершинами завжди має рівно V-1 ребер.'
        }
      ]
    },
    {
      id: 'test-bellman-ford-algorithm',
      title: 'Тест з алгоритму Беллмана-Форда',
      description: 'Перевірте своє розуміння алгоритму Беллмана-Форда для знаходження найкоротших шляхів у графах з від\'ємними вагами.',
      materialId: 'bellman-ford-algorithm',
      category: 'algorithms',
      difficulty: 'hard',
      estimatedTime: 30,
      passingScore: 80,
      questions: [
        {
          id: 'q1-bellman-ford',
          question: 'Яка часова складність алгоритму Беллмана-Форда?',
          options: ['O(V²)', 'O(E log V)', 'O(VE)', 'O(E²)'],
          correctAnswer: 2,
          explanation: 'Алгоритм Беллмана-Форда має часову складність O(VE) через обробку всіх ребер V-1 разів.'
        },
        {
          id: 'q2-bellman-ford',
          question: 'Яка основна перевага алгоритму Беллмана-Форда над алгоритмом Дейкстри?',
          options: [
            'Він може обробляти від\'ємні ваги ребер',
            'Він швидший для всіх типів графів',
            'Він використовує менше пам\'яті',
            'Він працює тільки на орієнтованих графах'
          ],
          correctAnswer: 0,
          explanation: 'Алгоритм Беллмана-Форда може обробляти від\'ємні ваги ребер та виявляти від\'ємні цикли, чого не може алгоритм Дейкстри.'
        },
        {
          id: 'q3-bellman-ford',
          question: 'Скільки ітерацій виконує алгоритм Беллмана-Форда для знаходження найкоротших шляхів?',
          options: [
            'V ітерацій',
            'V-1 ітерацій для найкоротших шляхів + 1 для виявлення циклів',
            'E ітерацій',
            'log V ітерацій'
          ],
          correctAnswer: 1,
          explanation: 'Беллман-Форд виконує V-1 ітерацій для знаходження найкоротших шляхів, плюс одну додаткову ітерацію для виявлення від\'ємних циклів.'
        },
        {
          id: 'q4-bellman-ford',
          question: 'Що відбувається, якщо Беллман-Форд виявляє від\'ємний цикл?',
          options: [
            'Він продовжує знаходити найкоротші шляхи',
            'Він повідомляє, що найкоротші шляхи не визначені',
            'Він видаляє від\'ємні ребра',
            'Він перетворює граф на додатні ваги'
          ],
          correctAnswer: 1,
          explanation: 'Коли виявлено від\'ємний цикл, найкоротші шляхи не визначені, оскільки можна продовжувати обходити цикл для отримання довільно малих відстаней.'
        },
        {
          id: 'q5-bellman-ford',
          question: 'З якими з наступних графів алгоритм Беллмана-Форда НЕ може працювати?',
          options: [
            'Графи з від\'ємними вагами ребер',
            'Графи з додатними вагами ребер',
            'Графи з від\'ємними циклами, досяжними з джерела',
            'Орієнтовані графи'
          ],
          correctAnswer: 2,
          explanation: 'Беллман-Форд може виявити від\'ємні цикли, але не може знайти значущі найкоротші шляхи, коли від\'ємні цикли досяжні з джерела.'
        }
      ]
    }
  ];
}; 