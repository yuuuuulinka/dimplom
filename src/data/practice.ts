import { PracticeProblem } from '../types/practice';

export const getProblems = (): PracticeProblem[] => {
  return [
    {
      id: 'bfs-shortest-path',
      title: 'Найкоротший шлях у незваженому графі',
      description: 'Знайдіть найкоротший шлях між двома вузлами у незваженому графі, використовуючи пошук в ширину.',
      difficulty: 'easy',
      topics: ['bfs', 'paths'],
      examples: [
        {
          input: 'Граф з 5 вузлами і 6 ребрами, Початок: A, Кінець: E',
          output: 'Найкоротший шлях: A → C → E, Довжина: 2',
          explanation: 'BFS досліджує всі шляхи довжиною 1, потім всі шляхи довжиною 2 і так далі, гарантуючи, що перший знайдений шлях є найкоротшим.'
        }
      ],
      constraints: [
        'Граф містить від 1 до 100 вузлів',
        'Граф є зв\'язним (існує принаймні один шлях між будь-якими двома вузлами)',
        'Граф є неорієнтованим'
      ],
      hint: 'Використовуйте чергу для відстеження вузлів, які потрібно відвідати, і масив відвіданих вузлів для уникнення циклів.',
      solution: 'Ініціалізуйте чергу з початковим вузлом. Для кожного вузла, який ви виймаєте з черги, якщо це ціль, ви знайшли найкоротший шлях. Інакше додайте всіх невідвіданих сусідів до черги та позначте їх як відвідані. Використовуйте масив батьків для відновлення шляху.',
      estimatedTime: 15,
      successRate: 85,
      attemptedCount: 1250,
      averageTime: 12,
      relatedProblems: [
        { id: 'connected-components', title: 'Знаходження зв\'язних компонент', difficulty: 'easy', topic: 'BFS' },
        { id: 'bipartite-graph', title: 'Перевірка на дводольність графа', difficulty: 'medium', topic: 'BFS' }
      ]
    },
    {
      id: 'cycle-detection',
      title: 'Виявлення циклу в неорієнтованому графі',
      description: 'Визначте, чи містить неорієнтований граф цикл, використовуючи пошук в глибину.',
      difficulty: 'medium',
      topics: ['dfs', 'graphs'],
      examples: [
        {
          input: 'Граф з ребрами: [(1,2), (2,3), (3,1)]',
          output: 'Істина (містить цикл)',
          explanation: 'Існує цикл 1 → 2 → 3 → 1.'
        },
        {
          input: 'Граф з ребрами: [(1,2), (2,3), (3,4)]',
          output: 'Хибність (немає циклу)',
          explanation: 'Граф є простим шляхом від 1 до 4.'
        }
      ],
      constraints: [
        'Граф містить від 1 до 100 вузлів',
        'Граф може бути не зв\'язним',
        'Кожне ребро з\'являється не більше одного разу'
      ],
      hint: 'Цикл існує, якщо ви зустрічаєте вузол, який вже був відвіданий, і він не є батьком поточного вузла.',
      solution: 'Виконайте обхід DFS. Для кожної вершини відстежуйте її батька. Якщо ви зустрічаєте вершину, яка вже була відвідана, і вона не є батьком поточної вершини, то існує цикл.',
      completed: true,
      estimatedTime: 20,
      successRate: 72,
      attemptedCount: 980,
      averageTime: 18,
      relatedProblems: [
        { id: 'directed-cycle', title: 'Виявлення циклу в орієнтованому графі', difficulty: 'medium', topic: 'DFS' },
        { id: 'topological-sort', title: 'Топологічне сортування', difficulty: 'medium', topic: 'DFS' }
      ]
    },
    {
      id: 'dijkstra-shortest-path',
      title: 'Найкоротший шлях у зваженому графі',
      description: 'Знайдіть найкоротший шлях між двома вузлами у зваженому графі, використовуючи алгоритм Дейкстри.',
      difficulty: 'medium',
      topics: ['dijkstra', 'paths'],
      examples: [
        {
          input: 'Граф з 4 вузлами і ребрами: [(A,B,1), (A,C,4), (B,C,2), (B,D,5), (C,D,1)], Початок: A, Кінець: D',
          output: 'Найкоротший шлях: A → B → C → D, Довжина: 4',
          explanation: 'Шлях A → C → D має довжину 5, але A → B → C → D має довжину 1 + 2 + 1 = 4.'
        }
      ],
      constraints: [
        'Граф містить від 1 до 100 вузлів',
        'Ваги ребер є додатними цілими числами від 1 до 1000',
        'Граф є зв\'язним'
      ],
      hint: 'Використовуйте чергу з пріоритетом, щоб завжди вибирати вузол з найменшою попередньою відстанню.',
      solution: 'Ініціалізуйте відстані до всіх вузлів як нескінченність, крім початкового вузла (0). Використовуйте чергу з пріоритетом для відстеження вузлів, які потрібно відвідати, завжди вибираючи вузол з найменшою поточною відстанню. Для кожного вузла оновлюйте відстані його сусідів, якщо знайдено коротший шлях. Використовуйте масив батьків для відновлення шляху.',
      estimatedTime: 25,
      successRate: 68,
      attemptedCount: 850,
      averageTime: 22,
      relatedProblems: [
        { id: 'bellman-ford', title: 'Найкоротші шляхи з від\'ємними вагами', difficulty: 'hard', topic: 'Bellman-Ford' },
        { id: 'a-star', title: 'Алгоритм пошуку A*', difficulty: 'hard', topic: 'Heuristic Search' }
      ]
    },
    {
      id: 'min-spanning-tree',
      title: 'Мінімальне кістякове дерево',
      description: 'Знайдіть мінімальне кістякове дерево зв\'язного неорієнтованого графа, використовуючи алгоритм Крускала.',
      difficulty: 'medium',
      topics: ['mst', 'graphs'],
      examples: [
        {
          input: 'Граф з ребрами: [(A,B,3), (A,C,5), (B,C,1), (B,D,4), (C,D,2)]',
          output: 'Ребра МКД: [(B,C,1), (C,D,2), (A,B,3)], Загальна вага: 6',
          explanation: 'Ребра (B,C), (C,D) і (A,B) утворюють дерево, що з\'єднує всі вузли з мінімальною загальною вагою.'
        }
      ],
      constraints: [
        'Граф містить від 1 до 100 вузлів',
        'Ваги ребер є додатними цілими числами від 1 до 1000',
        'Граф є зв\'язним'
      ],
      hint: 'Відсортуйте ребра за вагою та додайте їх до МКД, якщо вони не створюють цикл.',
      solution: 'Відсортуйте всі ребра за вагою. Ініціалізуйте структуру даних для відстеження множин для виявлення циклів. Обробляйте ребра в порядку зростання ваги, додаючи ребро до МКД, якщо воно не утворює цикл (використовуючи структуру даних для перевірки).',
      estimatedTime: 30,
      successRate: 62,
      attemptedCount: 720,
      averageTime: 28,
      relatedProblems: [
        { id: 'prims-algorithm', title: 'Алгоритм Прима для МКД', difficulty: 'medium', topic: 'MST' },
        { id: 'max-spanning-tree', title: 'Максимальне кістякове дерево', difficulty: 'medium', topic: 'MST' }
      ]
    },
    {
      id: 'topological-sort',
      title: 'Топологічне сортування',
      description: 'Виконайте топологічне сортування орієнтованого ациклічного графа (DAG).',
      difficulty: 'medium',
      topics: ['dfs', 'graphs'],
      examples: [
        {
          input: 'Граф з ребрами: [(A,B), (A,C), (B,D), (C,D)]',
          output: 'Топологічний порядок: A, B, C, D або A, C, B, D',
          explanation: 'A повинно йти перед B і C; B і C повинні йти перед D. Обидва порядки задовольняють ці обмеження.'
        }
      ],
      constraints: [
        'Граф містить від 1 до 100 вузлів',
        'Граф є орієнтованим ациклічним графом (DAG)',
        'Може існувати кілька валідних топологічних порядків'
      ],
      hint: 'Використовуйте DFS і відстежуйте час завершення. Альтернативно, використовуйте алгоритм Кана з підрахунком вхідних степенів.',
      solution: 'Виконайте обхід DFS графа. Після дослідження всіх сусідів вузла додайте його на початок зв\'язного списку. Кінцевий зв\'язний список міститиме валідний топологічний порядок. Альтернативно, повторно видаляйте вузли без вхідних ребер (вхідний степінь 0) і додавайте їх до порядку.',
      estimatedTime: 25,
      successRate: 70,
      attemptedCount: 680,
      averageTime: 23,
      relatedProblems: [
        { id: 'course-schedule', title: 'Проблема розкладу курсів', difficulty: 'medium', topic: 'Topological Sort' },
        { id: 'alien-dictionary', title: 'Інопланетний словник', difficulty: 'hard', topic: 'Topological Sort' }
      ]
    },
    {
      id: 'strongly-connected',
      title: 'Знаходження сильно зв\'язних компонент',
      description: 'Визначте всі сильно зв\'язні компоненти в орієнтованому графі, використовуючи алгоритм Косараю.',
      difficulty: 'hard',
      topics: ['dfs', 'graphs'],
      examples: [
        {
          input: 'Граф з ребрами: [(1,2), (2,3), (3,1), (3,4), (4,5), (5,4)]',
          output: 'СЗК: {1,2,3}, {4,5}',
          explanation: 'Вузли 1, 2 і 3 утворюють цикл, де кожен вузол може досягти інших. Вузли 4 і 5 утворюють інший цикл.'
        }
      ],
      constraints: [
        'Граф містить від 1 до 100 вузлів',
        'Граф є орієнтованим'
      ],
      hint: 'Запустіть DFS двічі: спочатку на оригінальному графі для отримання порядку завершення, а потім на транспонованому графі, слідуючи цьому порядку.',
      solution: 'Виконайте DFS на оригінальному графі і збережіть вузли в порядку їх часу завершення. Створіть транспонований граф (зверніть всі ребра). Виконайте другий DFS на транспонованому графі, починаючи з вузлів у спадному порядку часу завершення. Кожне DFS дерево в другому обході є сильно зв\'язною компонентою.',
      estimatedTime: 40,
      successRate: 55,
      attemptedCount: 420,
      averageTime: 38,
      relatedProblems: [
        { id: 'tarjan-scc', title: 'Алгоритм Тарьяна для СЗК', difficulty: 'hard', topic: 'DFS' },
        { id: 'bridges-articulation', title: 'Мости та точки зчленування', difficulty: 'hard', topic: 'DFS' }
      ]
    },
    {
      id: 'bipartite-graph',
      title: 'Перевірка на дводольність графа',
      description: 'Визначте, чи можна розфарбувати даний граф, використовуючи лише два кольори так, щоб жодні суміжні вузли не мали однакового кольору.',
      difficulty: 'medium',
      topics: ['bfs', 'dfs', 'graphs'],
      examples: [
        {
          input: 'Граф з ребрами: [(1,2), (2,3), (3,4), (4,1)]',
          output: 'Істина (є дводольним)',
          explanation: 'Ми можемо розфарбувати вузли 1 і 3 у червоний колір, а вузли 2 і 4 у синій.'
        },
        {
          input: 'Граф з ребрами: [(1,2), (2,3), (3,1)]',
          output: 'Хибність (не дводольний)',
          explanation: 'Цикл з непарною довжиною (3) не можна розфарбувати лише двома кольорами.'
        }
      ],
      constraints: [
        'Граф містить від 1 до 100 вузлів',
        'Граф є неорієнтованим'
      ],
      hint: 'Спробуйте розфарбувати граф двома кольорами за допомогою BFS або DFS. Якщо в будь-який момент ви зустрінете суперечність, граф не є дводольним.',
      solution: 'Почніть BFS з будь-якого вузла. Розфарбуйте його кольором 1. Для кожного сусіда розфарбуйте його протилежним кольором. Якщо ви зустрінете сусіда, який вже розфарбований тим же кольором, що й поточний вузол, граф не є дводольним. Продовжуйте BFS для всіх невідвіданих вузлів.',
      estimatedTime: 20,
      successRate: 75,
      attemptedCount: 580,
      averageTime: 18,
      relatedProblems: [
        { id: 'graph-coloring', title: 'Проблема розфарбування графа', difficulty: 'hard', topic: 'Graph Coloring' },
        { id: 'possibile-bipartition', title: 'Можливий двотомний розподіл', difficulty: 'medium', topic: 'BFS' }
      ]
    },
    {
      id: 'network-flow',
      title: 'Максимальний потік у мережі',
      description: 'Знайдіть максимальний потік від джерела до стоку в мережі потоків, використовуючи алгоритм Форда-Фалкерсона.',
      difficulty: 'hard',
      topics: ['graphs', 'network-flow'],
      examples: [
        {
          input: 'Мережа з ребрами (пропускна здатність): [(S,A,10), (S,B,8), (A,B,2), (A,T,8), (B,T,10)], Джерело: S, Стік: T',
          output: 'Максимальний потік: 18',
          explanation: 'Ми можемо послати потік 8 через S→A→T і потік 10 через S→B→T.'
        }
      ],
      constraints: [
        'Мережа містить від 2 до 50 вузлів',
        'Пропускні здатності ребер є додатними цілими числами від 1 до 100',
        'Існує принаймні один шлях від джерела до стоку'
      ],
      hint: 'Повторно знаходьте збільшувальні шляхи від джерела до стоку і оновлюйте залишкові пропускні здатності, поки не закінчаться збільшувальні шляхи.',
      solution: 'Ініціалізуйте потік як 0. Поки існує збільшувальний шлях від джерела до стоку в залишковому графі (використовуючи BFS або DFS): Знайдіть мінімальну пропускну здатність на цьому шляху. Додайте це значення до загального потоку. Оновіть залишкові пропускні здатності ребер на цьому шляху. Поверніть загальний потік.',
      estimatedTime: 45,
      successRate: 48,
      attemptedCount: 320,
      averageTime: 42,
      relatedProblems: [
        { id: 'edmonds-karp', title: 'Алгоритм Едмондса-Карпа', difficulty: 'hard', topic: 'Network Flow' },
        { id: 'min-cut', title: 'Проблема мінімального розрізу', difficulty: 'hard', topic: 'Network Flow' }
      ]
    },
    {
      id: 'prims-mst-construction',
      title: 'Побудова МКД за допомогою алгоритму Прима',
      description: 'Побудуйте мінімальне кістякове дерево зваженого неорієнтованого графа, використовуючи алгоритм Прима, починаючи з даної вершини.',
      difficulty: 'medium',
      topics: ['prims', 'mst', 'graphs'],
      examples: [
        {
          input: 'Граф з ребрами: [(A,B,4), (A,C,2), (B,C,1), (B,D,5), (C,D,8), (C,E,10), (D,E,2)], Початкова вершина: A',
          output: 'Ребра МКД: [(A,C,2), (C,B,1), (B,D,5), (D,E,2)], Загальна вага: 10',
          explanation: 'Починаючи з A, додаємо найдешевше ребро (A,C,2). Потім найдешевше ребро з {A,C} є (C,B,1). Далі найдешевше з {A,B,C} є (B,D,5). Нарешті, найдешевше з {A,B,C,D} є (D,E,2).'
        }
      ],
      constraints: [
        'Граф містить від 2 до 50 вершин',
        'Ваги ребер є додатними цілими числами від 1 до 100',
        'Граф є зв\'язним і неорієнтованим',
        'Початкова вершина завжди валідна'
      ],
      hint: 'Використовуйте чергу з пріоритетом для ефективного знаходження ребра з мінімальною вагою, що з\'єднує поточне МКД з новою вершиною. Відстежуйте, які вершини вже в МКД.',
      solution: 'Почніть з даної вершини в МКД. Підтримуйте чергу з пріоритетом ребер від вершин МКД до вершин не-МКД. Повторно витягуйте ребро з мінімальною вагою, що з\'єднується з новою вершиною, додайте цю вершину до МКД і додайте всі її ребра до не-МКД вершин у чергу з пріоритетом. Продовжуйте, поки всі вершини не будуть в МКД.',
      estimatedTime: 35,
      successRate: 65,
      attemptedCount: 420,
      averageTime: 32,
      relatedProblems: [
        { id: 'min-spanning-tree', title: 'Мінімальне кістякове дерево', difficulty: 'medium', topic: 'MST' },
        { id: 'kruskals-mst-construction', title: 'Побудова МКД за допомогою алгоритму Крускала', difficulty: 'medium', topic: 'MST' }
      ]
    },
    {
      id: 'kruskals-mst-construction',
      title: 'Побудова МКД за допомогою алгоритму Крускала',
      description: 'Побудуйте мінімальне кістякове дерево зваженого неорієнтованого графа, використовуючи алгоритм Крускала зі структурою даних Union-Find.',
      difficulty: 'medium',
      topics: ['kruskals', 'mst', 'union-find', 'graphs'],
      examples: [
        {
          input: 'Граф з ребрами: [(A,B,4), (A,C,2), (B,C,1), (B,D,5), (C,D,8), (C,E,10), (D,E,2), (A,E,7)]',
          output: 'Ребра МКД: [(B,C,1), (A,C,2), (D,E,2), (A,B,4)], Загальна вага: 9',
          explanation: 'Сортування ребер за вагою: (B,C,1), (A,C,2), (D,E,2), (A,B,4), (B,D,5), (A,E,7), (C,D,8), (C,E,10). Додаємо ребра по порядку, пропускаючи ті, що створюють цикл за допомогою Union-Find.'
        }
      ],
      constraints: [
        'Граф містить від 2 до 50 вершин',
        'Ваги ребер є додатними цілими числами від 1 до 100',
        'Граф є зв\'язним і неорієнтованим',
        'Кілька ребер між однією парою вершин не дозволені'
      ],
      hint: 'Спочатку відсортуйте всі ребра за вагою. Використовуйте структуру даних Union-Find для ефективної перевірки, чи створить додавання ребра цикл. МКД матиме рівно V-1 ребер.',
      solution: 'Відсортуйте всі ребра в порядку зростання ваги. Ініціалізуйте структуру Union-Find, де кожна вершина є своїм власним набором. Для кожного ребра в відсортованому порядку: якщо дві вершини в різних наборах (немає циклу), додайте ребро до МКД і об\'єднайте набори. Зупиніться, коли МКД має V-1 ребер.',
      estimatedTime: 40,
      successRate: 58,
      attemptedCount: 380,
      averageTime: 37,
      relatedProblems: [
        { id: 'prims-mst-construction', title: 'Побудова МКД за допомогою алгоритму Прима', difficulty: 'medium', topic: 'MST' },
        { id: 'union-find-operations', title: 'Структура даних Union-Find', difficulty: 'medium', topic: 'Union-Find' }
      ]
    },
    {
      id: 'bellman-ford-shortest-path',
      title: 'Найкоротші шляхи з від\'ємними вагами',
      description: 'Знайдіть найкоротші шляхи від вершини-джерела до всіх інших вершин у графі, який може містити ребра з від\'ємними вагами, використовуючи алгоритм Беллмана-Форда.',
      difficulty: 'hard',
      topics: ['bellman-ford', 'shortest-paths', 'negative-weights'],
      examples: [
        {
          input: 'Граф з ребрами: [(A,B,1), (A,C,4), (B,C,-3), (B,D,2), (C,D,3), (D,B,-5)], Джерело: A',
          output: 'Відстані: A=0, B=-2, C=-2, D=0. Шлях до B: A→B→C→D→B (довжина -2)',
          explanation: 'Спочатку A=0, інші=∞. Після релаксацій: A→B дає B=1, A→C дає C=4, B→C дає C=-2, тощо. Від\'ємне ребро D→B створює коротший шлях до B.'
        },
        {
          input: 'Граф з ребрами: [(A,B,1), (B,C,-3), (C,A,1)], Джерело: A',
          output: 'Виявлено від\'ємний цикл: A→B→C→A має загальну вагу -1',
          explanation: 'Цикл A→B→C→A має вагу 1+(-3)+1 = -1, створюючи від\'ємний цикл, що дозволяє нескінченне зменшення відстаней.'
        }
      ],
      constraints: [
        'Граф містить від 2 до 30 вершин',
        'Ваги ребер є цілими числами від -50 до 50',
        'Граф є орієнтованим',
        'Вершина-джерело завжди валідна'
      ],
      hint: 'Релаксуйте всі ребра V-1 раз для знаходження найкоротших шляхів. Потім зробіть ще одну ітерацію - якщо будь-яка відстань все ще може бути покращена, є від\'ємний цикл.',
      solution: 'Ініціалізуйте відстань до джерела як 0, інші як нескінченність. Повторіть V-1 раз: для кожного ребра (u,v) з вагою w, якщо dist[u] + w < dist[v], оновіть dist[v] = dist[u] + w. Після V-1 ітерацій перевірте ще раз - якщо будь-яка відстань може бути покращена, повідомте про від\'ємний цикл. Інакше поверніть відстані.',
      estimatedTime: 45,
      successRate: 52,
      attemptedCount: 280,
      averageTime: 41,
      relatedProblems: [
        { id: 'dijkstra-shortest-path', title: 'Найкоротший шлях у зваженому графі', difficulty: 'medium', topic: 'Dijkstra' },
        { id: 'floyd-warshall', title: 'Найкоротші шляхи між всіма парами', difficulty: 'hard', topic: 'Dynamic Programming' }
      ]
    }
  ];
};